Container RoadNetwork: Using = "Units;Geography;Classifications;Zones"
{
	unit<uint32> defNet: expr = "subset(Network/Flows > 0)"
	{
		attribute<rdc_meter>	line(arc): 	expr = "Network/UnionData[Nr_OrgEntity]", 	StorageName = "%dataDir%/createnetwork/smallBikeNet.shp";
		attribute<float32>		time:		expr = "Network/Time[Nr_OrgEntity]", 		StorageName = "%dataDir%/createnetwork/smallBikeNet.dbf";
	}
	unit<uint32>	Network: expr = "connect(OSMBikeNet/uniqueOSMSegments/line, Zones/ZoneSet/centroid)", DialogData = "UnionData", DialogType = "map"
	{
		attribute<rdc_meter> UnionData (arc);
		attribute<bool>		 notconnectlink:expr = "id(Network) == Nr_OrgEntity";
		attribute<rdc_meter> first_node: 	expr = "first_node(UnionData)";
		attribute<rdc_meter> last_node: 	expr = "last_node(UnionData)";
		attribute<float32>	 length:		expr = "arc_length(UnionData, float32)";
		attribute<float32>	 prototime:		expr = "(length * float32(1.2)) / float32(83.3333333)";
		
		unit<uint32> PointSet: 	expr = "union_unit(Network, Network)" {attribute<rdc_meter> Points: expr = "union_data(PointSet, first_node, last_node)"; attribute<NodeSet2D> Node2D: expr = "rlookup(Points, NodeSet2D/values)";}
		unit<uint32> NodeSet2D:	expr = "unique(PointSet/Points)", DialogData = "Values", DialogType = "Map" {attribute<rdc_meter> Values; attribute<uint32> nNodes: expr = "pcount(PointSet/Node2D)"; }
		
		attribute<NodeSet2D> F1: expr = "rlookup(first_node, NodeSet2D/Values)"; attribute<float32> F1time: expr = "switch(case(NodeSet2D/nNodes[F1] == 3, float32(0.1)), case(NodeSet2D/nNodes[F1] > 3, float32(0.2)), float32(0))";
		attribute<NodeSet2D> F2: expr = "rlookup(last_node, NodeSet2D/Values)"; attribute<float32> F2time: expr = "switch(case(NodeSet2D/nNodes[F2] == 3, float32(0.1)), case(NodeSet2D/nNodes[F2] > 3, float32(0.2)), float32(0))";
		
		attribute<float32>	 time: expr = "prototime + F1time + F2time";
		
		attribute<NodeSet2D> ZoneNode (Zones/ZoneSet): expr = "rlookup(Zones/ZoneSet/centroid, NodeSet2D/Values)";
		
		attribute<uint32>	Flows: expr = "= 'add('+ AsItemList('Network/ZoneDists/' + Zones/ZoneSet/sZoneId + '/TraceBack') + ')'";
		
		container ZoneDists: expr = "for_each_ne(Zones/ZoneSet/sZoneId, 'getDistances('+ string(Zones/ZoneSet/ZoneId) +')')";
	}
	

	
	unit<uint32>	OSMBikeNet: 
		 StorageName = "%dataDir%/createnetwork/BikeNetwork.dbf",
		 StorageReadOnly = "True",
		 SyncMode = "none",
		 DialogData = "line",
		 DialogType = "map"
	{
		attribute<rdc_meter> line(arc): StorageName = "%dataDir%/createnetwork/BikeNetwork.shp", StorageReadOnly = "True";
		
		unit<uint32> OSMBikeSegments: expr = "arc2segm(OSMBikeNet/line)"
		{
			attribute<rdc_meter> point; attribute<Nodes> firstNode: expr = "rlookup(point, Nodes/Values)";
			attribute<rdc_meter> nextpoint; attribute<Nodes> lastNode: expr = "rlookup(nextpoint, Nodes/Values)";
			unit<uint32> Doubled: 	expr = "union_unit(OSMBikeSegments, OSMBikeSegments)" {attribute<rdc_meter> points: expr = "union_data(Doubled, point, nextpoint)";}
			unit<uint32> Nodes:		expr = "unique(Doubled/points)" {attribute<rdc_meter> Values;}
			attribute<upoint>	uniqueId := point(max_elem(firstNode, lastNode), min_elem(firstNode, lastNode), upoint);	
		}
		
		unit<uint32> uniqueOSMSegments: expr = "unique(OSMBikeSegments/uniqueId)"
		{
			attribute<upoint> 		Values;
			attribute<rdc_meter>	point: 		expr = "OSMBikeSegments/Nodes/Values[pointCol(Values)]";		
			attribute<rdc_meter>	nextpoint: 	expr = "OSMBikeSegments/Nodes/Values[pointRow(Values)]";
			attribute<rdc_meter>	line(arc): 	expr = "points2sequence(makeLines/points, makeLines/Seq, makeLines/Ord)";
			attribute<float32>		length:		expr = "arc_length(line, float32)";
			
			unit<uint32> makeLines: expr = "union_unit(uniqueOSMSegments, uniqueOSMSegments)"
			{
				attribute<rdc_meter> points: 		expr = "union_data(makeLines, point, nextpoint)";	
				attribute<uniqueOSMSegments> Seq: 	expr = "union_data(makeLines, id(uniqueOSMSegments), id(uniqueOSMSegments))";
				attribute<uint32>	 Ord:			expr = "union_data(makeLines, const(0, uniqueOSMSegments, uint32), const(1, uniqueOSMSegments, uint32))";
			}
		}
	}
	
	container getDistances: IsTemplate = "True"
	{
		parameter<uint32> ZoneId;
		
		unit<uint32> selZone: expr = "subset(Zones/ZoneSet/ZoneId = ZoneId)"
		{
			attribute<rdc_meter> 			centroid: expr = "Zones/ZoneSet/centroid[Nr_OrgEntity]";
			attribute<Network/NodeSet2D>	FromNode: expr = "Network/ZoneNode[Nr_OrgEntity]";
		}
		
		attribute<float32>	distanceSet (Network/NodeSet2D): 	expr = "dijkstra(Network/time, Network/F1, Network/F2, selZone/FromNode)";
		attribute<uint32>	TraceBack	(Network):				expr = "trace_back(Network/F1, Network/F2, distanceSet/TraceBack, sum(const(1, Zones/ZoneSet, uint32), Network/ZoneNode))";
		
		unit<uint32>	UsedNetwork: expr = "subset(TraceBack > 0)" {attribute<Network> NetIds: expr = "Nr_OrgEntity";}
		
	}
	
}