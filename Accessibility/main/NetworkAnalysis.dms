container NetworkAnalysis: Using = "SourceData;Zones;Units;"
{
	
	Container HourlyMatrices: expr = "for_each_ne(hours/shour, 'getHourNetwork('+ string(hours/thishour) + ',' + string(hours/startHour) + ')')";
	
	//container HourNetwork: expr = "getHourNetwork(1200, 1100)";
	
	Container getHourNetwork: IsTemplate = "True"
	{
		parameter<uint32> inTime;
		parameter<uint32> startingFrom;
		
		unit<uint32> TimeSet:	expr = "unique(protoNetwork/PointSet/times)"
		{ attribute<uint32>	   Values; attribute<uint32> Time: expr = "Values";}
		
		unit<uint32> NodeSet2D: expr = "unique(protoNetwork/PointSet/points)", DialogData = "Values", Dialogtype = "map"
		{ 
			attribute<rdc_meter> 	Values; 
			attribute<bool> 		PTStop: expr = "max(protoNetwork/PointSet/PTStop, protoNetwork/PointSet/Node2D) > uint8(0)";
		}
		
		unit<uint32> NodeSet3D: expr = "unique(Network/PointSet3D/Points3D)", DialogData = "NodeLoc", DialogType = "map"
		{
			attribute<upoint> 		Values;
			attribute<NodeSet3D> 	Node3D: expr = "id(NodeSet3D)";
			attribute<NodeSet2D>	Node2D: expr = "rlookup(pointRow(Values), id(NodeSet2D))";
			attribute<TimeSet>		Time:	expr = "rlookup(pointCol(Values), id(TimeSet))";
			attribute<rdc_meter>	NodeLoc:expr = "NodeSet2D/Values[Node2D]";
			attribute<bool>			PTStop: expr = "NodeSet2D/PTStop[Node2D]";
		}
		
		
		
		unit<uint32> Network: expr = "union_unit(protoNetwork, protoNetwork/dblRoadNet)", DialogData = "line", DialogType = "map"
		{
			attribute<rdc_meter> line(arc): expr = "union_data(Network, protoNetwork/line, protoNetwork/dblRoadNet/line)";
			attribute<rdc_meter> first_node:expr = "union_data(Network, protoNetwork/first_node, protoNetwork/dblRoadNet/first_node)";	
			attribute<rdc_meter> last_node:	expr = "union_data(Network, protoNetwork/last_node, protoNetwork/dblRoadNet/last_node)";	
			attribute<uint32>	 fromtime:  expr = "union_data(Network, protoNetwork/fromtime, protoNetwork/dblRoadNet/fromtime)";	
			attribute<uint32>	 totime:  	expr = "union_data(Network, protoNetwork/totime, protoNetwork/dblRoadNet/totime)";	
			attribute<float32>	 travtime:  expr = "makedefined(union_data(Network, protoNetwork/travtime, protoNetwork/dblRoadNet/travtime), float32(0))";
			
			attribute<NodeSet2D> fromNode2D:expr = "rlookup(first_node, NodeSet2D/Values)";
			attribute<NodeSet2D> toNode2D:	expr = "rlookup(last_node, NodeSet2D/Values)";
			attribute<TimeSet>	 fTimeSet:  expr = "rlookup(fromtime, TimeSet/time)";
			attribute<TimeSet>	 tTimeSet:  expr = "rlookup(totime, TimeSet/time)";
			attribute<upoint>	 fPoint3D := point(fTimeSet, fromNode2D, upoint);
			attribute<upoint>	 tPoint3D := point(tTimeSet, toNode2D, upoint);
			
			unit<uint32> PointSet3D: expr = "union_unit(Network, Network)"
			{	attribute<upoint> Points3D: expr = "union_data(PointSet3D, fPoint3D, tPoint3D)"; }
			
			attribute<NodeSet2D> Zones2D 	(ZoneSet): expr = "rlookup(ZoneSet/centroid, NodeSet2D/Values)";
			attribute<upoint>	 ZonePoint3D(ZoneSet): expr = "point(Zones2D, rlookup(const(inTime, ZoneSet, uint32), TimeSet/Values), upoint)";
			attribute<prepareRoadNet/ConnectRoads/RoadNodeSet>
								ZoneRoadNode(ZoneSet): expr = "rlookup(ZoneSet/centroid, prepareRoadNet/ConnectRoads/RoadNodeSet/Values)";
						
			attribute<NodeSet3D> F1:		expr = "rlookup(fPoint3D, NodeSet3D/Values)";
			attribute<NodeSet3D> F2:		expr = "rlookup(tPoint3D, NodeSet3D/Values)";
			attribute<NodeSet3D> Zones3D	(ZoneSet): expr = "rlookup(ZonePoint3D, NodeSet3D/Values)";
			
			unit<uint32>	ex_ZoneSet: expr = "subset(ZoneSet/ZoneId == 1011)" {attribute<NodeSet3D> Node3D: expr = "Zones3D[Nr_OrgEntity]";}
					
			attribute<float32>	 impedance 	(NodeSet3D): 	expr = "dijkstra_directed(travtime, F1, F2, ex_ZoneSet/Node3D)";
			attribute<uint32>	TraceBack	(Network):		expr = "trace_back(F1, F2, impedance/TraceBack, sum(const(1, Zones/ZoneSet, uint32), Zones3D))";
			attribute<float32>   leastImp	(NodeSet2D): 	expr = "min(impedance, NodeSet3D/Node2D)";
			
			attribute<float32>  TimeToStops (Stops):		expr = "leastImp[Stops/Node2D]";
			attribute<float32>	PTImpedance (prepareRoadNet/ConnectRoads):
				expr = "prepareRoadNet/ConnectRoads/Time + MakeDefined(TimeToStops[prepareRoadNet/ConnectRoads/StopId], float32(0))";
			attribute<float32>	impToStops	(prepareRoadNet/ConnectRoads/RoadNodeSet):
				expr = "dijkstra(PTImpedance, prepareRoadNet/ConnectRoads/F2, prepareRoadNet/ConnectRoads/F1, Stops/RoadNode) + MakeDefined(TimeToStops[prepareRoadNet/ConnectRoads/RoadNodeSet/StopId], Float32(0))";		
			
			attribute<float32>	ProtoDistAdam	(FineSet): 		expr = "mean(impToStops, prepareRoadNet/ConnectRoads/RoadNodeSet/FineZone)"; // , StorageName 	= "%dataDir%/results/distTo1011.dbf";	
			attribute<float32>	DistAdam		(FineSet): 		expr = "iif(ProtoDistAdam > float32(999999) || IsNull(ProtoDistAdam), float32(-1), ProtoDistAdam)";			
								
			unit<uint32>	checkLinks: expr = "subset(TraceBack > 0)", DialogData = "line", DialogType = "map"
			{
				attribute<rdc_meter> line (arc): 	expr = "Network/line[Nr_OrgEntity]", StorageName 	= "%dataDir%/results/traceback1011.shp";
				attribute<uint32>	 flows: 		expr = "TraceBack[Nr_OrgEntity]", StorageName 	= "%dataDir%/results/traceback1011.dbf";
				attribute<uint32>	 fTime:			expr = "fromtime[NR_Orgentity]", StorageName 	= "%dataDir%/results/traceback1011.dbf";
				attribute<uint32>	 tTime:			expr = "totime[NR_Orgentity]", StorageName 	= "%dataDir%/results/traceback1011.dbf";
				attribute<float32>	 time:			expr = "Network/travtime[Nr_OrgEntity]", StorageName 	= "%dataDir%/results/traceback1011.dbf";
				attribute<uint32>	 fromNode:		expr = "F1[Nr_OrgEntity]", StorageName 	= "%dataDir%/results/traceback1011.dbf";	
				attribute<uint32>	 toNode:		expr = "F2[Nr_OrgEntity]", StorageName 	= "%dataDir%/results/traceback1011.dbf";	
				attribute<uint32>	 fNode2D:		expr = "fromNode2D[Nr_OrgEntity]", StorageName 	= "%dataDir%/results/traceback1011.dbf";				
				attribute<uint32>	 tNode2D:		expr = "toNode2D[Nr_OrgEntity]", StorageName 	= "%dataDir%/results/traceback1011.dbf";
			}
			
			unit<uint32>	ODMatrix: expr = "= 'union_unit('+ AsItemList('Distances/' + ZoneSet/sZoneId + '/Zones') + ')'"
			{
				attribute<uint32> 	orgZone:  	expr = "= 'union_data(ODMatrix, '+ AsItemList('Distances/' + ZoneSet/sZoneId + '/Zones/orgZone') + ')'", 	StorageName 	= "= '%dataDir%/results/ODMatrix_'+ string(inTime) + '.dbf'";
				attribute<uint32> 	destZone:  	expr = "= 'union_data(ODMatrix, '+ AsItemList('Distances/' + ZoneSet/sZoneId + '/Zones/destZone') + ')'", 	StorageName 	= "= '%dataDir%/results/ODMatrix_'+ string(inTime) + '.dbf'";
				attribute<float32> 	ZoneDist:  	expr = "= 'union_data(ODMatrix, '+ AsItemList('Distances/' + ZoneSet/sZoneId + '/Zones/ZoneDist') + ')'", 	StorageName 	= "= '%dataDir%/results/ODMatrix_'+ string(inTime) + '.dbf'";
				attribute<ZoneSet>	destID:		expr = "rlookup(destZone, ZoneSet/ZoneId)";
				attribute<ZoneSet>	orgID:		expr = "rlookup(orgZone, ZoneSet/ZoneId)";
				attribute<float32>	defDist: 	expr = "iif(ZoneDist > float32(0), ZoneDist, float32(0))"; 
				
				unit<uint32> Zones: expr = "FineSet"
				{
					attribute<rdc_meter> vlak (poly): 	expr = "FineSet/vlak", 			StorageName 	= "= '%dataDir%/results/distto1011_'+ string(inTime) + '.shp'";	
					attribute<float32>	 disttAdam:		expr = "DistAdam", 				StorageName 	= "= '%dataDir%/results/distto1011_'+ string(inTime) + '.dbf'";
				}
				unit<uint32> access: expr = "ZoneSet"
				{
					attribute<rdc_meter> vlak(poly):expr = "ZoneSet/vlak", 		StorageName 	= "= '%dataDir%/results/access'+ string(inTime) + '.shp'";		
					attribute<float32>	 central: 	expr = "sum(defDist, orgId)", StorageName 	= "= '%dataDir%/results/access'+ string(inTime) + '.dbf'";
					attribute<float32>	 access: 	expr = "sum(float32(PC4Zones/Households[destID]) / defDist, orgId)", StorageName 	= "= '%dataDir%/results/access'+ string(inTime) + '.dbf'";
				}
			}
			
			unit<uint32> CellAccess: expr = "CellSet"
			{
				attribute<uint32> gridcode:	expr = "CellSet/GridCode", StorageName 	= "= '%dataDir%/results/cellaccess'+ string(inTime) + '.dbf'";
				attribute<float32>acc1: 	expr = "= 'add(' + AsItemList('Distances/' + ZoneSet/sZoneId + '/acc1') + ')'",   StorageName 	= "= '%dataDir%/results/cellaccess'+ string(inTime) + '.dbf'";
				attribute<float32>acc15: 	expr = "= 'add(' + AsItemList('Distances/' + ZoneSet/sZoneId + '/acc15') + ')'",  StorageName 	= "= '%dataDir%/results/cellaccess'+ string(inTime) + '.dbf'";
				attribute<float32>acc2: 	expr = "= 'add(' + AsItemList('Distances/' + ZoneSet/sZoneId + '/acc2') + ')'",   StorageName 	= "= '%dataDir%/results/cellaccess'+ string(inTime) + '.dbf'";
				attribute<uint32> h10min: 	expr = "= 'add(' + AsItemList('Distances/' + ZoneSet/sZoneId + '/h10min') + ')'", StorageName 	= "= '%dataDir%/results/cellaccess'+ string(inTime) + '.dbf'";
				attribute<uint32> h20min: 	expr = "= 'add(' + AsItemList('Distances/' + ZoneSet/sZoneId + '/h20min') + ')'", StorageName 	= "= '%dataDir%/results/cellaccess'+ string(inTime) + '.dbf'";
				attribute<uint32> h30min: 	expr = "= 'add(' + AsItemList('Distances/' + ZoneSet/sZoneId + '/h30min') + ')'", StorageName 	= "= '%dataDir%/results/cellaccess'+ string(inTime) + '.dbf'";
				attribute<uint32> h45min: 	expr = "= 'add(' + AsItemList('Distances/' + ZoneSet/sZoneId + '/h45min') + ')'", StorageName 	= "= '%dataDir%/results/cellaccess'+ string(inTime) + '.dbf'";
				attribute<uint32> h60min: 	expr = "= 'add(' + AsItemList('Distances/' + ZoneSet/sZoneId + '/h60min') + ')'", StorageName 	= "= '%dataDir%/results/cellaccess'+ string(inTime) + '.dbf'";
			}
				

			container Distances: 	expr = "for_each_ne(ZoneSet/sZoneId, 'getDistances(' + string(ZoneSet/ZoneId) + ')')";
			
			container getDistances: IsTemplate = "True"
			{
				parameter<uint32> inZoneId;
				
				unit<uint32> DestNodes: expr = "subset(ZoneSet/ZoneId = inZoneId)"	
				{	attribute<NodeSet3D> DestNode: expr = "Zones3D[Nr_OrgEntity]";}
				
				attribute<float32>	 impedance 	(NodeSet3D): 	expr = "dijkstra_directed(travtime, F1, F2, DestNodes/DestNode)";
				attribute<uint32>	TraceBack	(Network):		expr = "trace_back(F1, F2, impedance/TraceBack, sum(const(1, Zones/ZoneSet, uint32), Zones3D))";
				attribute<float32>   leastImp	(NodeSet2D): 	expr = "min(impedance, NodeSet3D/Node2D)";
			
				attribute<float32>  TimeToStops (Stops):		expr = "leastImp[Stops/Node2D]";
				attribute<float32>	PTImpedance (prepareRoadNet/ConnectRoads):
					expr = "MakeDefined(prepareRoadNet/ConnectRoads/Time, float32(0)) + MakeDefined(TimeToStops[prepareRoadNet/ConnectRoads/StopId], float32(0))";
				attribute<float32>	impToStops	(prepareRoadNet/ConnectRoads/RoadNodeSet):
					expr = "dijkstra(PTImpedance, prepareRoadNet/ConnectRoads/F1, prepareRoadNet/ConnectRoads/F2, Stops/RoadNode) + MakeDefined(TimeToStops[prepareRoadNet/ConnectRoads/RoadNodeSet/StopId], Float32(0))";		
				
				unit<uint32>	Zones: expr = "ZoneSet"
				{
					attribute<ZoneSet>  orgZone: 	expr = "ZoneSet/ZoneId";
					attribute<ZoneSet>  destZone: 	expr = "const(inZoneId, Zones, uint32)";
					attribute<float32>	ProtoDist: 	expr = "mean(impToStops, prepareRoadNet/ConnectRoads/RoadNodeSet/inZone)"; // , StorageName 	= "%dataDir%/results/distTo1011.dbf";	
					attribute<float32>	ZoneDist: 	expr = "iif(ProtoDist > float32(999999) || IsNull(ProtoDist), float32(-1), ProtoDist)";	
				}
				unit<uint32> 	Cells: expr = "CellSet"
				{
					attribute<Cells>  	orgZone: 	expr = "id(Cells)";
					attribute<ZoneSet>  destZone: 	expr = "rlookup(const(inZoneId, Cells, uint32), ZoneSet/ZoneId)";
					attribute<float32>	ProtoDist: 	expr = "mean(impToStops, prepareRoadNet/ConnectRoads/RoadNodeSet/CellId)"; // , StorageName 	= "%dataDir%/results/distTo1011.dbf";	
					attribute<float32>	ZoneDist: 	expr = "iif(ProtoDist > float32(999999) || IsNull(ProtoDist), float32(-1), ProtoDist)";	
				}
				attribute<float32>acc1	 (CellSet): expr = "iif(Cells/ZoneDist > float32(0), (float32(PC4Zones/Households[Cells/destZone]) / Cells/ZoneDist), 				float32(0))";
				attribute<float32>acc15	 (CellSet): expr = "iif(Cells/ZoneDist > float32(0), (float32(PC4Zones/Households[Cells/destZone]) / Cells/ZoneDist^float32(1.5)),	float32(0))";
				attribute<float32>acc2	 (CellSet): expr = "iif(Cells/ZoneDist > float32(0), (float32(PC4Zones/Households[Cells/destZone]) / Cells/ZoneDist^float32(2)), 	float32(0))";
				attribute<uint32> h10min (CellSet): expr = "sum(iif(Cells/ZoneDist > float32(0) && Cells/ZoneDist <= float32(10), 	PC4Zones/Households[Cells/destZone], 0), Cells/orgZone)";
				attribute<uint32> h20min (CellSet): expr = "sum(iif(Cells/ZoneDist > float32(10) && Cells/ZoneDist <= float32(20), 	PC4Zones/Households[Cells/destZone], 0), Cells/orgZone)";
				attribute<uint32> h30min (CellSet): expr = "sum(iif(Cells/ZoneDist > float32(20) && Cells/ZoneDist <= float32(30), 	PC4Zones/Households[Cells/destZone], 0), Cells/orgZone)";
				attribute<uint32> h45min (CellSet): expr = "sum(iif(Cells/ZoneDist > float32(30) && Cells/ZoneDist <= float32(45), 	PC4Zones/Households[Cells/destZone], 0), Cells/orgZone)";
				attribute<uint32> h60min (CellSet): expr = "sum(iif(Cells/ZoneDist > float32(45) && Cells/ZoneDist <= float32(60), 	PC4Zones/Households[Cells/destZone], 0), Cells/orgZone)";
			}
			
		}
		unit<uint32> inStops: 	expr = "subset(sourceNets/WaitTimes/fromTime > (startingFrom - 1) && sourceNets/WaitTimes/fromTime < (inTime + 1))" // fromtime is the time a route stops in a node (and waiting begins).
		{ 
			attribute<rdc_meter> point: expr = "sourceNets/WaitTimes/point[Nr_OrgEntity]"; 
			attribute<uint32> fromTime: expr = "sourceNets/WaitTimes/fromTime[Nr_OrgEntity]"; 
			attribute<uint32> toTime: expr = "sourceNets/WaitTimes/toTime[Nr_OrgEntity]"; 
			attribute<Stops> uniqueStop: expr = "rlookup(point, Stops/Values)";
			
			unit<uint32> uniTime: expr = "unique(fromTime)" {attribute<uint32> Values; attribute<string> sFtime: expr = "'s' + string(Values)";}
		}
		
		
		unit<uint32> Stops: 	expr = "unique(inStops/point)", DialogData = "Values", DialogType = "map"
		{ 
			attribute<rdc_meter>Values; 
			attribute<uint32> 	minSelTime: expr = "min(inStops/toTime, inStops/uniqueStop)"; 
			attribute<uint32> 	maxSelTime: expr = "max(inStops/fromTime, inStops/uniqueStop)";
			attribute<NodeSet2D>Node2D:		expr = "rlookup(Values, NodeSet2D/Values)"; 
			attribute<prepareRoadNet/ConnectRoads/RoadNodeSet> RoadNode: expr = "rlookup(Values, prepareRoadNet/ConnectRoads/RoadNodeSet/Values)";
		}
		
		
		container prepareRoadNet
		{	
			// based on the premise that dijkstra calculates the time of arrival at inTime (this is fixed!)
			// so that the maximum time is selected in which transport ends < inTime
			container TimeConnectors: expr = "for_each_ne(inStops/uniTime/sFtime, 'getTimeConnectors('+ string(inStops/uniTime/Values) + ')')";
			
			unit<uint32> protoRoads1: expr = "connect(sourceNets/RoadLines/line, Stops/Values)", 	DialogData = "Uniondata",DialogType = "map"	
			{ attribute<rdc_meter> UnionData (arc); attribute<bool>		 Road:	expr = "!IsNull(Nr_OrgEntity)"; }
			unit<uint32> protoRoads2: expr = "subset(protoRoads1/Road)"
			{ attribute<rdc_meter> UnionData (arc): expr = "protoRoads1/UnionData[Nr_OrgEntity]"; }
			unit<uint32> connectedRoadSet:  expr = "connect(protoRoads2/UnionData, ZoneSet/centroid)"
			{ attribute<rdc_meter> UnionData (arc); }
						
			unit<uint32> ConnectRoads: expr = "= 'union_unit(connectedRoadSet' + AsList(', TimeConnectors/' + inStops/uniTime/sFtime + '/connectlinks', '') + ')'",
			DialogData = "Uniondata",
			DialogType = "map"	
			{
				attribute<rdc_meter> 	UnionData (arc):expr = "= 'union_data(ConnectRoads, connectedRoadSet/UnionData'+ AsList(', TimeConnectors/' + inStops/uniTime/sFtime + '/connectlinks/connector', '') + ')'";
				attribute<rdc_meter> 	first_node:		expr = "first_node(UnionData)";
				attribute<rdc_meter> 	last_node:		expr = "last_node(UnionData)";
				attribute<float32>		length:			expr = "arc_length(UnionData, float32)";
				attribute<bool>			connectLink:	expr = "= 'union_data(ConnectRoads, const(false, connectedRoadSet, bool) ' + AsList(', TimeConnectors/' + inStops/uniTime/sFtime + '/connectlinks/connectlink', '') + ')'";
				
				attribute<uint32>		protoFromTime:	expr = "= 'union_data(ConnectRoads, const(inTime, connectedRoadSet, uint32)'+ AsList(', TimeConnectors/' + inStops/uniTime/sFtime + '/connectlinks/fromtime', '') + ')'";
				attribute<uint32>		protoToTime:	expr = "const(inTime, ConnectRoads, uint32)";
				attribute<uint32>	 	fromTime: 		expr = "iif(protoFromTime > 59 && (uint32(substr(string(protoFromTime), (strlen(string(protoFromTime)) -2), 2)) > 59), ((protoFromTime + 100) - 60), protoFromTime)";	
				attribute<uint32>	 	toTime: 		expr = "iif(protoToTime > 59 && (uint32(substr(string(protoToTime), (strlen(string(protoToTime)) -2), 2)) > 59), ((protoToTime + 100) - 60), protoToTime)";	
				
				attribute<float32>		Time:			expr = "length / float32(83.3333333)";
				attribute<Stops>		fromStopId:		expr = "rlookup(first_node, Stops/Values)";
				attribute<Stops>		toStopId:		expr = "rlookup(last_node, Stops/Values)";
				attribute<Stops>		StopId:			expr = "iif(IsNull(fromStopId), toStopId, fromStopId)";
				
				unit<uint32> RoadPointSet: expr = "union_unit(ConnectRoads, ConnectRoads)"
				{ attribute<rdc_meter> points: expr = "union_data(RoadPointSet, first_node, last_node)";	}
				
				unit<uint32> RoadNodeSet:	expr = "unique(RoadPointSet/points)", DialogData = "Values", Dialogtype = "map"
				{ 
					attribute<rdc_meter> Values; 
					attribute<ZoneSet> 	inZone: 	expr = "point_in_polygon(Values, ZoneSet/vlak)"; 
					attribute<FineSet> 	FineZone: 	expr = "point_in_polygon(Values, FineSet/vlak)"; 
					attribute<CellSet>	CellId: 	expr = "point_in_polygon(Values, CellSet/vlak)";
					attribute<Stops> 	StopId: 	expr = "rlookup(Values, Stops/Values)";
				}
				
				attribute<RoadNodeSet> F1: expr = "rlookup(first_node, RoadNodeSet/Values)";
				attribute<RoadNodeSet> F2: expr = "rlookup(last_node, RoadNodeSet/Values)";
			}
			container getTimeConnectors: IsTemplate = "true"
			{
				parameter<uint32> aTime;
				
				unit<uint32> timeSet: expr = "subset(inStops/fromTime == aTime)"	
				{
					attribute<rdc_meter> point: expr = "inStops/point[Nr_OrgEntity]";	
				}
				unit<uint32> connectors: expr = "connect(sourceNets/RoadLines/line, timeSet/point)"
				{
					attribute<rdc_meter>UnionData(arc);
					attribute<bool>		ConnectLink: expr = "IsNull(Nr_OrgEntity)";
				}
				unit<uint32> connectlinks: expr = "subset(connectors/ConnectLink)"
				{
					attribute<rdc_meter>connector(arc): expr = "Connectors/Uniondata[Nr_OrgEntity]";
					attribute<uint32>	fromtime:		expr = "const(aTime, connectlinks, uint32)";
					attribute<uint32>	totime:			expr = "const(inTime, connectlinks, uint32)";
					attribute<bool>		connectlink:	expr = "connectors/ConnectLink[Nr_OrgEntity]";
				}
				
			}
		}
		
		// carry connectlink + indicator that link is from the connectroads data (needs to be doubled for the connecting graph)
		// protofromtimes here: to catch exceptions in which tiems are indicated as e.g. "460" or "1161"
		unit<uint32> protoNetwork: expr = "union_unit(sourceNets/AllPTConnections, sourceNets/WaitTimes, prepareRoadNet/ConnectRoads)", DialogData = "line", DialogType = "map"
		{
			attribute<rdc_meter> line(arc): 	expr = "union_data(protoNetwork, sourceNets/AllPTConnections/line, sourceNets/WaitTimes/line, prepareRoadNet/ConnectRoads/UnionData)";
			attribute<uint32>	 protofromTime: expr = "union_data(protoNetwork, sourceNets/AllPTConnections/fromTime, sourceNets/WaitTimes/fromTime, prepareRoadNet/ConnectRoads/fromTime)";
			attribute<uint32>	 protoToTime:  	expr = "union_data(protoNetwork, sourceNets/AllPTConnections/toTime, sourceNets/WaitTimes/toTime, prepareRoadNet/ConnectRoads/toTime)";
			attribute<uint32>	 fromTime: 		expr = "iif(protoFromTime > 59 && (uint32(substr(string(protoFromTime), (strlen(string(protoFromTime)) -2), 2)) > 59), ((protoFromTime + 100) - 60), protoFromTime)";
			attribute<uint32>	 toTime:		expr = "iif(protoToTime > 59 && (uint32(substr(string(protoToTime), (strlen(string(protoToTime)) -2), 2)) > 59), ((protoToTime + 100) - 60), protoToTime)";
			attribute<uint32>	 fromHourMin:	expr = "iif(fromTime > 59, uint32(substr(string(fromTime), 0, (strlen(string(fromTime)) - 2))), fromTime) * 60";
			attribute<uint32>	 toHourMin:		expr = "iif(toTime > 59, uint32(substr(string(toTime), 0, strlen(string(toTime)) - 2)), 0) * 60";
			attribute<uint32>	 fromMin:		expr = "iif(fromTime > 59, uint32(substr(string(fromTime), (strlen(string(fromTime)) -2), 2)), fromTime)";
			attribute<uint32>	 toMin:		 	expr = "iif(toTime > 59, uint32(substr(string(toTime), (strlen(string(toTime)) -2), 2)), toTime)";
			attribute<float32>	 protoTravTime:	expr = "union_data(protoNetwork, const(0.5, sourceNets/AllPTConnections, float32), const(0.5, sourceNets/WaitTimes, float32), prepareRoadNet/ConnectRoads/Time)";
			attribute<float32>	 travTime:		expr = "MakeDefined(iif(fromTime == toTime || connectLink, protoTravTime, float32((toHourMin + toMin) - (fromHourMin + fromMin))), float32(0.5))";
			attribute<bool>		 PTNet:			expr = "union_data(protoNetwork, const(True,  sourceNets/AllPTConnections, bool),  const(false, sourceNets/WaitTimes, bool),const(False, prepareRoadNet/ConnectRoads, bool))";
			attribute<bool>	 	 connectLink:	expr = "union_data(protoNetwork, const(false, sourceNets/AllPTConnections, bool),  const(false, sourceNets/WaitTimes, bool),prepareRoadNet/ConnectRoads/connectLink )";
			attribute<bool>		 roadNetwork:	expr = "union_data(protoNetwork, const(false, sourceNets/AllPTConnections, bool),  const(false, sourceNets/WaitTimes, bool),const(true, prepareRoadNet/ConnectRoads, bool))";
			attribute<rdc_meter> first_node:	expr = "first_node(line)";
			attribute<rdc_meter> last_node:		expr = "last_node(line)";
			
			unit<uint32> PointSet: expr = "union_unit(protoNetwork, protoNetwork)"
			{ 
				attribute<rdc_meter> points:expr = "union_data(PointSet, first_node, last_node)"; 
				attribute<uint32> times: 	expr = "union_data(PointSet, fromtime, totime)"; 
				attribute<uint8> PTStop: 	expr = "uint8(union_data(PointSet, PTnet, PTnet))";
				attribute<NodeSet2D> Node2D:expr = "rlookup(points, NodeSet2D/values)";
			}
			
			unit<uint32> dblRoadNet: expr = "subset(roadNetwork)"
			{
				attribute<rdc_meter>	line(arc): 	expr = "protoNetwork/line[Nr_OrgEntity]";
				attribute<rdc_meter>	first_node: expr = "protoNetwork/last_node[Nr_OrgEntity]";
				attribute<rdc_meter>	last_node: 	expr = "protoNetwork/first_node[Nr_OrgEntity]";
				attribute<uint32>		fromtime:	expr = "protoNetwork/totime[Nr_OrgEntity]";
				attribute<uint32>		totime:		expr = "protoNetwork/fromtime[Nr_OrgEntity]";
				attribute<float32>		travTime: 	expr = "protoNetwork/travTime[Nr_OrgEntity]";
			}
		}
	}
	
	
	container sourceNets
	{
		unit<uint32>	AllPTConnections: 
			label           = "all connections",
			StorageName 	= "%dataDir%/createnetwork/net_ibt.dbf",
			DialogData      = "line",
			DialogType      = "Map",
			SyncMode        = "none",
			StorageReadOnly = "True"
		{
			attribute<rdc_meter>	line(arc): 	label= "connections between routes", StorageName = "%dataDir%/createnetwork/net_ibt.shp", StorageReadOnly = "True";
			attribute<uint32>		fromtime;
			attribute<uint32>		toTime;
			attribute<float32>		time;
		}
		
		unit<uint32> WaitTimes: 	
			label           = "wait times",
			StorageName 	= "%dataDir%/createnetwork/waitTimes.dbf",
			DialogData      = "line",
			DialogType      = "Map",
			SyncMode        = "none",
			StorageReadOnly = "True"
		{
			attribute<rdc_meter>point: Label = "nodelocation", StorageName = "%dataDir%/createnetwork/waitTimes.shp", StorageReadOnly = "True";
			attribute<uint32>	fromTime;
			attribute<uint32>	toTime;
			attribute<float32>	time;
			attribute<rdc_meter>line (arc): expr = "points2sequence(makeLines/point, makeLines/Sequence, makeLines/Ordinal)";
				
			unit<uint32> makeLines: expr = "union_unit(WaitTimes, WaitTimes)"
			{
				attribute<rdc_meter> point: 	expr = "union_data(makeLines, WaitTimes/point, WaitTimes/point)";
				attribute<WaitTimes> Sequence:	expr = "union_data(makeLines, id(WaitTimes), id(WaitTimes))";
				attribute<uint32>	 Ordinal:	expr = "union_data(makeLines, const(0, WaitTimes, uint32), const(1, WaitTimes, uint32))";
			}
		}
		
		// road net moet nog verdubbeld en verdraaid worden
		unit<uint32>	RoadLines: 
			label           = "underlying road net",
			StorageName 	= "%dataDir%/createnetwork/smallBikeNet.dbf",
			DialogData      = "line",
			DialogType      = "Map",
			SyncMode        = "none",
			StorageReadOnly = "True"
		{
			attribute<rdc_meter>	line(arc): 	label= "connections between routes", StorageName = "%dataDir%/createnetwork/smallBikeNet.shp", StorageReadOnly = "True";
			attribute<float32>		time;
		}
	}		
	
	
	
}
