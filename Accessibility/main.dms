container OVGTFS
{ 
	container ConfigSettings
	{
		container Overridable
		{
			parameter<String> GTFSDataDir       := 'C:/GeoDMS/SourceData/GTFS/data';
		}
	}
	
	container MaakOntkoppeldeData
	{
		container FirstUse
		{
			parameter<String> Generate_All := 'Ready', ExplicitSuppliers = "OSM/Prepare_SourceData;OSM/NetworkPreperation;GTFS_2_FSS/Generate_GTSF_FSS";
		}
		container RegioIndelingen
		{
			// parameter<String> Generate_Buurten := 'Ready', ExplicitSuppliers = "RegioIndelingen/impl/Make_Buurten_fss";
			// parameter<String> Generate_PC6 := 'Ready', ExplicitSuppliers = "RegioIndelingen/impl/Make_PC6_areas_FSS ";
		}
		container OSM
		{
			parameter<String> Prepare_SourceData := 'Ready', ExplicitSuppliers = "SourceData/OSM/Prepare_SourceData/Generate";
			parameter<String> NetworkPreperation := 'Ready', ExplicitSuppliers = "SourceData/OSM/NetworkPreperation/Network_with_extraverbindingen/Generate";
		}
		container GTFS_2_FSS
		{
			parameter<String> Generate_GTSF_FSS := 'Ready', ExplicitSuppliers = "/SourceData/GTFS/LoadFeeds/storefss";
		}
	}
	
	container ModelParameters : using = "units"
	{
		parameter<string>   Onderzoeksmoment := 'NaOpeningOkt'; //'VoorOpening' 'NaOpeningJuli' 'NaOpeningOkt' 'NOVI'
		
		
		
		
		parameter<string>   GTFS_FileDate    := Onderzoeksmoment == 'VoorOpening' 
													? '20180530'
													: Onderzoeksmoment == 'NaOpeningJuli'
														? '20180723'
														: Onderzoeksmoment == 'NaOpeningOkt'
															? '20181008'
															: Onderzoeksmoment == 'Date_NaOpening2022'
																? '20220322'
																: '';
		parameter<string>   Analysis_date     := Onderzoeksmoment == 'VoorOpening' 
													? Date_voorOpening
													: Onderzoeksmoment == 'NaOpeningJuli'
														? Date_NaOpeningJuli
														: Onderzoeksmoment == 'NaOpeningOkt'
															? Date_NaOpeningOkt
															: Date_NaOpening2022;
													
		parameter<string>   Date_voorOpening   := '20180605';
		parameter<string>   Date_NaOpeningJuli := '20180724';
		parameter<string>   Date_NaOpeningOkt  := '20181009';
		parameter<string>   Date_NaOpening2022 := '20220329';
		
		parameter<string>   OSM_Date           := '20200117';
		
		parameter<string>   PrevDate        := string(uint32(Analysis_date) - 1);
		parameter<string>   Date_prefix     := substr(Analysis_date, 0, 4) + '/' + substr(Analysis_date, 4, 2) + '/' +  substr(Analysis_date, 6, 2);
		
		parameter<Weekdays> Today           := 1[Weekdays];
		parameter<Weekdays> Yesterday       := Weekdays/PrevRef[Today];
		
		parameter<string>   NetwerkExtent        := 'Amsterdam'; //'Amsterdam' 'Nederland'               //netwerk schaal
		parameter<string>   StudyArea            := 'Amsterdam'; //'NL' 'Amsterdam'                             //studyarea tbv trip selecties
		parameter<string>   Orgset               := 'Point100m'; //'PC6full' 'PC6sub' 'PC4full' 'PC4sub' PC6sub_MRA PC6sub_Pijp Point100m  Buurtsub_MRA  //org punten selectie
		parameter<string>   Destset              := 'LISA'; //'LISA' 'ARRA' 'Inwoners'                        //dest punten selectie
		parameter<string>   banen_locaties_schaal := '100m'; //'500m' '1000m' '5000m'   100m                  //dest punten schaal
		
		parameter<string>   Arrival_or_Departure_at_time := 'Departure'; // 'Arrival'  'Departure'
		
		parameter<m_s>     TransferEffectiveSpeed  := 0.93[m_s]; // 4/1.2= 3.33 km/h --> 0.93 m/s  // expressed in kilometers per hour, modified for manhattan distances
	
		parameter<m>        MaxTransferDistKm            := 500[m];                      //Maximale euclidische loopafstand tussen OV-haltes voor overstappen, in meters.
		parameter<float32>  MaxODconn                    := 25f;                       //Maximum aantal haltes dat bij de org of de dest wordt gezocht
		parameter<min_f>    MaxWalkingTime_Org2Stop      := 30[min_f];                      //Maximum looptijd van org naar eerste halte, in seconden. x  MaxWalkingDistSelection_Org2Stop
		parameter<min_f>    MaxWalkingTime_Stop2Dest     := 30[min_f];                      //Maximum looptijd van de laatste stop naar dest, in seconden. x
		parameter<min_f>    MaxBikingTime_Org2Stop       := 30[min_f];                      //Maximum fietstijd van org naar eerste halte, in seconden. x
		parameter<min_f>    MaxBikingTime_Stop2Dest      := 30[min_f];                      //Maximum fietstijd van laatste halte naar dest, in seconden. x
		parameter<min_f>    MaxWalkingTime_Org2Dest      := 30[min_f];                 //Maximale looptijd wanneer er direct van org naar dest locatie wordt gelopen, in seconden.
		parameter<min_f>    MaxBikingTime_Org2Dest       := 30[min_f];                 //Maximale fietstijd wanneer er direct van org naar dest locatie wordt gefietst, in seconden.
		parameter<min_f>    MaxOVTime                    := 30[min_f];                 //Maximale reistijd met OV. Te gebruiken om de rekentijd te verkorten. LET OP: hierdoor worden mogelijk de verste locaties niet bereikt. Wannneer een distance decay wordt gebruikt is niet zo erg. Maar bij een volledige OD wel! 
		parameter<min_f>    MaxCarTime                   := 30[min_f];                //Maximale reistijd met lopen/fiets/auto //120
		parameter<min_f>    OngelijkvloersPenalty        := 0[min_f];                 //Is er sprake van een halte waar je veel verticale afstand moet afleggen? Dan kun je daar een tijd penalty voor geven bij het overstappen, in seconden.
	
	
		parameter<float32>  WegingWachttijdThuisVoortransport := 0f; //0= geen wachttijd thuis meenemen, 1= wel wachttijd meenemen.
	
		parameter<bool>     OSM_NL_prov             := FALSE;                        //OSM data NL in provincies opgesplitst?
		parameter<km_hr>    WalkingSpeed_kmhr       := 4.8[km_hr];
		parameter<km_hr>    BikingSpeed_kmhr        := 16[km_hr];
		parameter<m_s>      WalkingSpeed            := WalkingSpeed_kmhr / 3600[s_f / hr_f] * 1000[m / km];
		parameter<m_s>      BikingSpeed             := BikingSpeed_kmhr / 3600[s_f / hr_f] * 1000[m / km];
		parameter<km_hr>    MaxCarSpeed             := 130[km_hr];
		parameter<km_hr>    MaxCarSpeed_limit       := 100[km_hr];
		parameter<km_hr>    CarDefaultSpeed         := 50[km_hr];
		parameter<km_hr>    CarDefaultSpeed_low     := 30[km_hr];
		parameter<km_hr>    Ferry_Speed             := 10[km_hr];
		
		unit<uint32> SampleDay := select_with_attr_by_org_rel(Time, Time/Day = 0) //Hier worden de analyse tijdstippen opgegeven. LET OP: Verander je deze dan zul je ook de NDW_meetmomenten/time moeten aanpassen. En de ChosenMoments ook wanneer er meer/minder momenten opgegeven zijn.
		{
			attribute<bool>    ChosenMoments   := =AsList(HoursMinutes/str,' || ');
			attribute<Time>    Time_rel        := org_rel;
			
			unit<uint8> ChosenHours : nrofrows = 2
			{
				attribute<uint32> values : [7, 8];
			}
			unit<uint8> ChosenMinutes : nrofrows = 4
			{
				attribute<uint32> values : [0,3,7,16];
			}
			unit<uint8> HoursMinutes := combine_uint8(ChosenHours, ChosenMinutes)
			{
				attribute<uint32> Hours     := ChosenHours/values[first_rel];
				attribute<uint32> Minutes   := ChosenMinutes/values[second_rel];
				attribute<string> str       := '(hour == '+string(Hours)+' && minute == '+string(Minutes)+' && second == 0)';
			}
		}
	
		unit<uint32> MeasureMoments := select_with_attr_by_cond(SampleDay, SampleDay/ChosenMoments)
		{
			attribute<Time>    Moment := Time_rel;
			attribute<string>  Name   := Time/TemplatableText[Moment];
		}
		
		unit<uint32> TransitionType_list : nrofrows = 2
		{
			attribute<string> Type     : ['Org2Stop_W'   ,'Stop2Dest_W'];
			attribute<string> Mode     : ['Walk'         ,'Walk'];
			attribute<string> FromTime : ['FromTime_Walk','FromTime_Walk'];
			attribute<string> ToTime   : ['ToTime_Walk'  ,'ToTime_Walk'];
			attribute<string> OrgDest  : ['Org'          ,'Dest'];
			attribute<min_f>  ModeMax  := ='union_data(.,MaxWalkingTime_Org2Stop,MaxWalkingTime_Stop2Dest)';
		}
		
		container OSM_impl
		{
			unit<uint32> InEenBestand : nrofrows = 1
			{
				unit<uint32> Elements  := Range(uint32, 0, nrAttr*#.)
				{
					attribute<String> Text:
					// Regio             , OrgSet , OrgPath, Land, Type, 
					[
					'Netherlands'             ,'NL', 'OD'

					// 'Belgium'                 ,'BE', 'OD',

					// 'Niedersachsen'           ,'DE', 'OD',
					// 'Nordrhein-Westfalen'     ,'DE', 'OD'
					]; 
				}
				
				attribute<string>        label          := Elements/Text[value(UInt32(ID(.))* nrAttr + 0, Elements)], DialogType = "LabelText";
				attribute<string>        name           := replace(label, '-', '_');
				attribute<string>        Country        := Elements/Text[value(UInt32(ID(.))* nrAttr + 1, Elements)];
				attribute<string>        Type_src       := Elements/Text[value(UInt32(ID(.))* nrAttr + 2, Elements)];
				
				parameter<uint32> nrAttr := 3;
			}
			unit<uint32> InProvincies : nrofrows = 12
			{
				unit<uint32> Elements  := Range(uint32, 0, nrAttr*#.)
				{
					attribute<String> Text:
					// Regio             , OrgSet , OrgPath, Land, Type, 
					[
					'Drenthe'                 ,'NL', 'OD',
					'Flevoland'               ,'NL', 'OD',
					'Friesland'               ,'NL', 'OD',
					'Gelderland'              ,'NL', 'OD',
					'Groningen'               ,'NL', 'OD',
					'Limburg'                 ,'NL', 'OD',
					'Noord-Brabant'           ,'NL', 'OD',
					'Noord-Holland'           ,'NL', 'OD',
					'Overijssel'              ,'NL', 'OD',
					'Utrecht'                 ,'NL', 'OD',
					'Zeeland'                 ,'NL', 'OD',
					'Zuid-Holland'            ,'NL', 'OD'

					// 'Belgium'                 ,'BE', 'OD',

					// 'Niedersachsen'           ,'DE', 'OD',
					// 'Duesseldorf-regbez'       ,'DE', 'OD',
					// 'Koeln-regbez'             ,'DE', 'OD',
					// 'Muenster-regbez'          ,'DE', 'OD'
					]; 
				}
				
				attribute<string>        label          := Elements/Text[value(UInt32(ID(.))* nrAttr + 0, Elements)], DialogType = "LabelText";
				attribute<string>        name           := replace(label, '-', '_');
				attribute<string>        Country        := Elements/Text[value(UInt32(ID(.))* nrAttr + 1, Elements)];
				attribute<string>        Type_src       := Elements/Text[value(UInt32(ID(.))* nrAttr + 2, Elements)];
				
				parameter<uint32> nrAttr := 3;
			}
		}
		
		unit<uint32> OSM_Regios := =OSM_NL_prov ? 'OSM_impl/InProvincies' : 'OSM_impl/InEenBestand'
		{
			attribute<string>        label          := =OSM_NL_prov ? 'OSM_impl/InProvincies/label' : 'OSM_impl/InEenBestand/label';
			attribute<string>        name           := =OSM_NL_prov ? 'OSM_impl/InProvincies/name' : 'OSM_impl/InEenBestand/name';
			attribute<string>        Country        := =OSM_NL_prov ? 'OSM_impl/InProvincies/Country' : 'OSM_impl/InEenBestand/Country';
			attribute<string>        Type_src       := =OSM_NL_prov ? 'OSM_impl/InProvincies/Type_src' : 'OSM_impl/InEenBestand/Type_src';
			
			attribute<AnalyseRegios> AnalyseRegios_rel := rlookup(country, AnalyseRegios/short);
			
			attribute<bool>          IsOD_Regio      := Type_src == 'OD';
			
			
			unit<uint32> OD_regios := subset(IsOD_Regio)
			{
				attribute<string> name  := ../name[nr_OrgEntity];
				attribute<string> label := ../label[nr_OrgEntity];
			}
			
			unit<uint32> Countries : nrofrows = 1
			{
				attribute<string> name : 
					[
						// 'Germany'
						 'Netherlands'
						// , 'Belgium'
					];
			}
			
			unit<uint32> Germany := subset(country == 'DE')
			{
				attribute<string> name  := ../name[nr_OrgEntity];
				attribute<string> label := ../label[nr_OrgEntity];
			}
			unit<uint32> Netherlands := subset(country == 'NL')
			{
				attribute<string> name  := ../name[nr_OrgEntity];
				attribute<string> label := ../label[nr_OrgEntity];
			}
			unit<uint32> Belgium := subset(country == 'BE')
			{
				attribute<string> name  := ../name[nr_OrgEntity];
				attribute<string> label := ../label[nr_OrgEntity];
			}
			
		}
		
		unit<uint32> AnalyseRegios : nrofrows = 1 // Hier worden de paden voor elke org set opgegeven. En wanneer er nieuwe bij komen dat hier ook toegevoegd worden.
		{
			unit<uint32> Elements  := Range(uint32, 0, nrAttr*#.)
			{
				attribute<String> Text:
				// Regio             , OrgSet , OrgPath, Land, Type, 
				[
				'Netherlands'             , 'PC4' , '/SourceData/RegioIndelingen/Dutch_PC4_areas'      ,'NL'
				]; 
			}

			attribute<string>        name          := Elements/Text[value(UInt32(ID(.))* nrAttr + 0, Elements)], DialogType = "LabelText";
			attribute<string>        OrgSet        := Elements/Text[value(UInt32(ID(.))* nrAttr + 1, Elements)];
			attribute<string>        OrgSet_path   := Elements/Text[value(UInt32(ID(.))* nrAttr + 2, Elements)];
			attribute<string>        short         := Elements/Text[value(UInt32(ID(.))* nrAttr + 3, Elements)];
			
			parameter<uint32> nrAttr := 4;
		}
	
	}
	
	// unit<fpoint> CoordSys := geometries/rdc;
	
	#include<units.dms>
	
	container geometries
	{
		#include <ngr_layer.dms>

		unit<fpoint> rdc_base : format = "EPSG:28992", DialogData = "ngr_layer";
		// unit<fpoint> rdc      := range(rdc_base, point(300000f,0f), point(625000f,280000f));
		unit<fpoint> rdc      := range(rdc_base, point(0f, 300000f), point(280000f, 625000f)); //heel NL
		unit<ipoint> rdc_mm   := gridset(rdc, point(0.001,0.001), point(0.0, 0.0), ipoint);
		
		unit<dpoint>  wgs84_base : format = "EPSG:4326";
		
		unit<uint32> selection_polygon : nrofrows = 1, Using = "units"
		{
			parameter<rdc> top_left     := point(NL_grid/x_min - 5000[m], NL_grid/y_max + 5000[m], rdc); //XY
			parameter<rdc> top_right    := point(NL_grid/x_max + 5000[m], NL_grid/y_max + 5000[m], rdc);
			parameter<rdc> bottom_left  := point(NL_grid/x_min - 5000[m], NL_grid/y_min - 5000[m], rdc);
			parameter<rdc> bottom_right := point(NL_grid/x_max + 5000[m], NL_grid/y_min - 5000[m], rdc);
			
			unit<uint32> point_set : nrofrows = 5
			{
				attribute<rdc>  point        := union_data(., top_left, top_right, bottom_right, bottom_left, top_left);
				attribute<..>   sequence_rel := const(0, .);
				attribute<.>    ordinal      := id(.);
			}
			
			attribute<rdc> polygon (poly)      := points2sequence(point_set/point, point_set/sequence_rel, point_set/ordinal);
			
		}
		unit<uint32> selection_polygon_MRA : nrofrows = 1, Using = "units"
		{
			parameter<rdc> top_left     := point(NL_grid/x_min + 20000[m], NL_grid/y_max - 20000[m], rdc); //XY
			parameter<rdc> top_right    := point(NL_grid/x_max - 20000[m], NL_grid/y_max - 20000[m], rdc);
			parameter<rdc> bottom_left  := point(NL_grid/x_min + 20000[m], NL_grid/y_min + 20000[m], rdc);
			parameter<rdc> bottom_right := point(NL_grid/x_max - 20000[m], NL_grid/y_min + 20000[m], rdc);
			
			unit<uint32> point_set : nrofrows = 5
			{
				attribute<rdc>  point        := union_data(., top_left, top_right, bottom_right, bottom_left, top_left);
				attribute<..>   sequence_rel := const(0, .);
				attribute<.>    ordinal      := id(.);
			}
			
			attribute<rdc> polygon (poly)      := points2sequence(point_set/point, point_set/sequence_rel, point_set/ordinal);
			
		}
		
		container NL_grid: Using = "units"
		{
			parameter<m> gridsize     := 100[m];
			parameter<m> gridsize_500m := 500[m];
			parameter<m> gridsize_1000m := 1000[m];
			parameter<m> gridsize_5000m := 5000[m];
			
			parameter<m> x_min := ModelParameters/StudyArea == 'NL' ? Nederland/x_min : Amsterdam/x_min;
			parameter<m> x_max := ModelParameters/StudyArea == 'NL' ? Nederland/x_max : Amsterdam/x_max;
			parameter<m> y_min := ModelParameters/StudyArea == 'NL' ? Nederland/y_min : Amsterdam/y_min;
			parameter<m> y_max := ModelParameters/StudyArea == 'NL' ? Nederland/y_max : Amsterdam/y_max;
			
			container Amsterdam
			{
				parameter<m> x_min := 75000[m];
				parameter<m> x_max := 165000[m];
				parameter<m> y_min := 445000[m];
				parameter<m> y_max := 530000[m];
			}
			
			container Nederland
			{
				parameter<m> x_min := 0[m];
				parameter<m> x_max := 280000[m];
				parameter<m> y_min := 300000[m];
				parameter<m> y_max := 625000[m];
			}
			
			parameter<int16> nr_cols := int16((x_max - x_min) / gridsize);
			parameter<int16> nr_rows := int16((y_max - y_min) / gridsize);

			unit<spoint> domain :=
				range(
					 gridset(
						 rdc
						,point(gridsize, -gridsize, rdc)
						,point(x_min, y_max, rdc)
						,spoint
					)
					,point(0s, 0s)
					,point(nr_cols, nr_rows)
				)
			,	DialogData = "rdc"
			,	DialogType = "map"
			{
				attribute<.>               id             := id(.);
				attribute<rdc>             point_rd       := id[rdc] + point(0.5f * gridsize, -0.5f * gridsize, rdc);
				attribute<uint32>          identificatie  := (pointcol(id)[uint32] + 1) + ((pointrow(id)[uint32]) * 250);
				attribute<domain_1000m>    grid_1000m_rel := id(.)[domain_1000m];
				
			}
			
			unit<uint32> points_100m := Subset(isDefined(domain/id))
			,	DialogData = "geometry"
			,	DialogType = "map"
			{
				attribute<rdc> 	                geometry  := domain/point_rd[nr_OrgEntity];	
				attribute<uint32>               id        := domain/identificatie[nr_OrgEntity];
				
				attribute<float32>              x         := PointCol(geometry);
				attribute<float32>              y         := PointRow(geometry);
				
				attribute<NL_grid/domain>       NL_grid_domain_rel  := geometry[NL_grid/domain];
				attribute<bool>                 IsNederland         := IsDefined(point_in_polygon(geometry, SourceData/RegioIndelingen/Provincies/Geometry));
				attribute<bool>                 IsBuurtenSub        := IsDefined(point_in_polygon(geometry, SourceData/RegioIndelingen/Buurten/zonder_water_unioned/Geometry));
				
				unit<uint32> MakePoints_100m_Buurt := subset(IsBuurtenSub)
				,	DialogData = "geometry"
				,	DialogType = "map"
				,	FreeData = "false"
				,	StorageName     = "%LocalDataDir%/NZlijn/Points_100m_buurt.fss"
				{
					attribute<rdc> 	                geometry  := points_100m/geometry[nr_OrgEntity];
					attribute<rdc> 	                point     := geometry;
					attribute<uint32>               id        := points_100m/id[nr_OrgEntity];
					attribute<NL_grid/domain>       NL_grid_domain_rel  := geometry[NL_grid/domain];
					attribute<string>               label     := 'p'+string(id), DialogType = "LabelText";
					attribute<string>               name      := label;
				}
				unit<uint32> Points_100m_Buurt
				:	DialogData = "geometry"
				,	DialogType = "map"
				,	FreeData = "false"
				,	StorageName     = "%LocalDataDir%/NZlijn/Points_100m_buurt.fss"
				,	StorageReadOnly = "true"
				{
					attribute<rdc> 	                geometry;
					attribute<NL_grid/domain>       per_grid := geometry[NL_grid/domain];
					attribute<rdc> 	                point;
					attribute<uint32>               id;
					attribute<NL_grid/domain>       NL_grid_domain_rel;
					attribute<string>               label: DialogType = "LabelText";
					attribute<string>               name;
				}
			}
			
			///////////////////////
			parameter<int16> nr_cols_500m := int16((x_max - x_min) / gridsize_500m);
			parameter<int16> nr_rows_500m := int16((y_max - y_min) / gridsize_500m);
			
			unit<spoint> domain_500m_untiled :=
				range(
					 gridset(
						 rdc
						,point(gridsize_500m, -gridsize_500m, rdc)
						,point(x_min, y_max, rdc)
						,spoint
					)
					,point(0s, 0s)
					,point(nr_cols_500m, nr_rows_500m)
				)
			,	DialogData = "rdc"
			{
				attribute<domain>      grid_100m_rel    := id(.)[domain];
			}

			unit<spoint> domain_500m := TiledUnit(Point(1000s, 1200s, domain_500m_untiled))
			{
				attribute<.>               id               := id(.);
				attribute<rdc>             point_rd         := id[rdc] + point(0.5f * gridsize_500m, -0.5f * gridsize_500m, rdc);
				attribute<uint32>          identificatie    := (pointcol(id)[uint32] + 1) + ((pointrow(id)[uint32]) * 250);
				attribute<string>          id_name          := 'p' + string(identificatie);
			}
			
			unit<uint32> points_500m := Subset(isDefined(domain_500m/id))
			,	DialogData = "geometry"
			,	DialogType = "map"
			{
				attribute<rdc> 	                geometry  := domain_500m/point_rd[nr_OrgEntity];	
				attribute<uint32>               id        := domain_500m/identificatie[nr_OrgEntity];
				
				attribute<float32>              x         := PointCol(geometry);
				attribute<float32>              y         := PointRow(geometry);
				
				attribute<NL_grid/domain_500m> NL_grid_domain_500m_rel  := geometry[NL_grid/domain_500m];	
			}
			
			///////////////////////
			parameter<int16> nr_cols_1000m := int16((x_max - x_min) / gridsize_1000m);
			parameter<int16> nr_rows_1000m := int16((y_max - y_min) / gridsize_1000m);
			
			unit<spoint> domain_1000m_untiled :=
				range(
					 gridset(
						 rdc
						,point(gridsize_1000m, -gridsize_1000m, rdc)
						,point(x_min, y_max, rdc)
						,spoint
					)
					,point(0s, 0s)
					,point(nr_cols_1000m, nr_rows_1000m)
				)
			,	DialogData = "rdc"
			{
				attribute<domain>      grid_100m_rel    := id(.)[domain];
			}

			unit<spoint> domain_1000m := TiledUnit(Point(1000s, 1200s, domain_1000m_untiled))
			{
				attribute<.>               id               := id(.);
				attribute<rdc>             point_rd         := id[rdc] + point(0.5f * gridsize_1000m, -0.5f * gridsize_1000m, rdc);
				attribute<uint32>          identificatie    := (pointcol(id)[uint32] + 1) + ((pointrow(id)[uint32]) * 250);
			}
			
			unit<uint32> points_1000m := Subset(isDefined(domain_1000m/id))
			,	DialogData = "geometry"
			,	DialogType = "map"
			{
				attribute<rdc> 	                geometry  := domain_1000m/point_rd[nr_OrgEntity];	
				attribute<uint32>               id        := domain_1000m/identificatie[nr_OrgEntity];
				
				attribute<float32>              x         := PointCol(geometry);
				attribute<float32>              y         := PointRow(geometry);
				
				attribute<NL_grid/domain_1000m> NL_grid_domain_1000m_rel  := geometry[NL_grid/domain_1000m];	
			}
			
			///////////////////////
			parameter<int16> nr_cols_5000m := int16((x_max - x_min) / gridsize_5000m);
			parameter<int16> nr_rows_5000m := int16((y_max - y_min) / gridsize_5000m);
			
			unit<spoint> domain_5000m_untiled :=
				range(
					 gridset(
						 rdc
						,point(gridsize_5000m, -gridsize_5000m, rdc)
						,point(x_min, y_max, rdc)
						,spoint
					)
					,point(0s, 0s)
					,point(nr_cols_5000m, nr_rows_5000m)
				)
			,	DialogData = "rdc"
			{
				attribute<domain>      grid_100m_rel    := id(.)[domain];
			}

			unit<spoint> domain_5000m := TiledUnit(Point(1000s, 1200s, domain_5000m_untiled))
			{
				attribute<.>               id               := id(.);
				attribute<rdc>             point_rd         := id[rdc] + point(0.5f * gridsize_5000m, -0.5f * gridsize_5000m, rdc);
				attribute<uint32>          identificatie    := (pointcol(id)[uint32] + 1) + ((pointrow(id)[uint32]) * 250);
			}
			
			unit<uint32> points_5000m := Subset(isDefined(domain_5000m/id))
			,	DialogData = "geometry"
			,	DialogType = "map"
			{
				attribute<rdc> 	                geometry  := domain_5000m/point_rd[nr_OrgEntity];	
				attribute<uint32>               id        := domain_5000m/identificatie[nr_OrgEntity];
				
				attribute<float32>              x         := PointCol(geometry);
				attribute<float32>              y         := PointRow(geometry);
				
				attribute<NL_grid/domain_5000m> NL_grid_domain_5000m_rel  := geometry[NL_grid/domain_5000m];	
			}
		}

	}
	
	#include<Classifications.dms>
	#include<SourceData.dms>
	#include<Network.dms>
	
	#include<Analysis.dms>
	
	
	#include<Templates.dms>
	
	#include<ExportSettings.dms>
}
